#parse("header.vm")
#parse("definitions.vm")
import org.jetbrains.research.kfg.ir.Class
import org.jetbrains.research.kfg.type.ClassType
import org.jetbrains.research.kfg.type.TypeFactory
import kotlin.reflect.KClass

enum class TypeSize (val int: Int) {
    WORD(1), DWORD(2);
}

open class ${Factory} : ${SMTFactory}() {
    companion object {

        fun getTypeSize(type: KexType) = when (type.bitsize) {
            KexType.WORD -> TypeSize.WORD
            KexType.DWORD -> TypeSize.DWORD
            else -> unreachable { log.error("Unknown type bitsize ${ type.bitsize }") }
        }

        fun getType(type: KexType) = when (type) {
            is KexLong -> Long_::class
            is KexBool -> Bool_::class
            is KexIntegral -> Int_::class
            is KexFloat -> Float_::class
            is KexDouble -> Double_::class
            is KexPointer -> Ptr_::class
            else -> unreachable { log.error("Unable to get ${solver} type for ${ type }") }
        }

    }

    open val ctx = SolverContext_()

#macro(generateMakes $type $basetype)
    #set($underlined = "${type}_")
    fun make$type(name: String, fresh: Boolean = false) =
            if (fresh) ${underlined}.makeFreshVar(ctx, name) else ${underlined}.makeVar(ctx, name)
    fun make${type}Const(value: $basetype) = ${underlined}.makeConst(ctx, value)
#end

#generateMakes("Ptr" "Int")
    fun makeNull() = makePtrConst(0)

#generateMakes("Bool", "Boolean")
    fun makeTrue() = makeBoolConst(true)
    fun makeFalse() = makeBoolConst(false)

#generateMakes("Short", "Int")
    fun makeShortConst(value: Short) = makeShortConst(value.toInt())
#generateMakes("Char", "Int")
    fun makeCharConst(value: Char) = makeCharConst(value.toInt())

#generateMakes("Int", "Int")

#generateMakes("Long", "Long")

#generateMakes("Float", "Float")

#generateMakes("Double", "Double")

    inline fun < reified  Element: Dynamic_ > makeEmptyMemory(id: String, type: KClass< out Element >) = Memory_.makeFree< Ptr_, Element >(ctx, id, type)
    //            makeDefaultMemory(id, 0xFF)
    inline fun < reified  Element: Dynamic_ > makeDefaultMemory(id: String, default: Int, type: KClass< out Element >) =
        Memory_.makeDefault< Ptr_, Element >(ctx, id, makeIntConst(default) as Element, type)

#set($types = ["Bool", "Short", "Char", "Int", "Long", "Float", "Double"])
    open fun getVarByTypeAndName(type: KexType, name: String, fresh: Boolean = false) = when(type) {
#foreach($type in $types)
        is Kex${type} -> make${type}(name, fresh)
#end
        is KexByte -> makeInt(name, fresh)
        is KexClass -> makePtr(name, fresh)
        is KexArray -> makePtr(name, fresh)
        is KexNull -> makePtr(name, fresh)
        else -> unreachable { log.error("Unknown type in ExprFactory: ${ type }") }
    }

    inline fun < T : Dynamic_, reified U : Dynamic_ > switch(value: T, cases: Map< T, U >, default: U) =
        cases.toList().fold(default) { acc, pair -> `if`(value eq pair.first).then(pair.second).`else`(acc) }

    inline fun < reified U : Dynamic_ > switch(cases: Map< Bool_, U >, default: U) =
        cases.toList().fold(default) { acc, pair -> `if`(pair.first).then(pair.second).`else`(acc) }

    inline fun < reified U : Dynamic_ > if_(cond: Bool_) = `if`(cond)

    fun forAll(sortGen: () -> List< Dynamic_ >, func: (List< Dynamic_ >) -> Bool_): Bool_ = forall(ctx, sortGen, func)

    fun forAll(sortGen: () -> List< Dynamic_ >, func: (List< Dynamic_ >) -> Bool_, patternGenerator: (List< Dynamic_ >) -> List< Dynamic_ >): Bool_ =
        forall(ctx, sortGen, func, patternGenerator)
}
